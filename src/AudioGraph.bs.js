// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Belt_Id = require("bs-platform/lib/js/belt_Id.js");
var Belt_Set = require("bs-platform/lib/js/belt_Set.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");

function cmp(param, param$1) {
  var c = Caml_obj.caml_compare(param[0], param$1[0]);
  if (c !== 0) {
    return c;
  }
  var c$1 = Caml_obj.caml_compare(param[1], param$1[1]);
  if (c$1 !== 0) {
    return c$1;
  }
  var c$2 = Caml_obj.caml_compare(param[2], param$1[2]);
  if (c$2 !== 0) {
    return c$2;
  } else {
    return Caml_obj.caml_compare(param[3], param$1[3]);
  }
}

var EdgeComparator = Belt_Id.MakeComparable({
      cmp: cmp
    });

var emptyEdgeSet = Belt_Set.make(EdgeComparator);

var emptyAudioGraph = {
  nodes: undefined,
  edges: emptyEdgeSet,
  actuallyConnectedEdges: emptyEdgeSet
};

function getNode(key, graph) {
  return Belt_MapString.get(graph.nodes, key);
}

function addNode(param, graph) {
  return {
          nodes: Belt_MapString.set(graph.nodes, param[0], param[1]),
          edges: graph.edges,
          actuallyConnectedEdges: graph.actuallyConnectedEdges
        };
}

function partitionEdgesWithNode(key, edgeSet) {
  return Belt_Set.partition(edgeSet, (function (param) {
                if (key === param[0]) {
                  return true;
                } else {
                  return key === param[1];
                }
              }));
}

function removeAllEdgesInvolvingNode(key, graph) {
  return {
          nodes: graph.nodes,
          edges: partitionEdgesWithNode(key, graph.edges)[1],
          actuallyConnectedEdges: graph.actuallyConnectedEdges
        };
}

function removeNode(key, graph) {
  return {
          nodes: Belt_MapString.remove(graph.nodes, key),
          edges: graph.edges,
          actuallyConnectedEdges: graph.actuallyConnectedEdges
        };
}

function addEdge(edge, graph) {
  return {
          nodes: graph.nodes,
          edges: Belt_Set.add(graph.edges, edge),
          actuallyConnectedEdges: graph.actuallyConnectedEdges
        };
}

function removeEdge(edge, graph) {
  return {
          nodes: graph.nodes,
          edges: Belt_Set.remove(graph.edges, edge),
          actuallyConnectedEdges: graph.actuallyConnectedEdges
        };
}

function maybeApplyToGraph(f, param, graph) {
  var inputIndex = param[3];
  var outputIndex = param[2];
  var targetId = param[1];
  var sourceId = param[0];
  var maybeSource = Belt_MapString.get(graph.nodes, sourceId);
  var maybeTarget = Belt_MapString.get(graph.nodes, targetId);
  if (maybeSource !== undefined && maybeTarget !== undefined) {
    Curry._4(f, maybeSource, maybeTarget, outputIndex, inputIndex);
    return /* tuple */[
            sourceId,
            targetId,
            outputIndex,
            inputIndex
          ];
  }
  
}

function disconnectEdges(edgesToDisconnect, graph) {
  return Belt_Set.forEach(edgesToDisconnect, (function (edge) {
                maybeApplyToGraph((function (prim, prim$1, prim$2, prim$3) {
                        prim.disconnect(prim$1, prim$2, prim$3);
                        
                      }), edge, graph);
                
              }));
}

function updateConnections(graph) {
  var edgesToConnect = Belt_Set.diff(graph.edges, graph.actuallyConnectedEdges);
  var edgesToDisconnect = Belt_Set.diff(graph.actuallyConnectedEdges, graph.edges);
  disconnectEdges(edgesToDisconnect, graph);
  var nowConnected = Belt_Set.reduce(edgesToConnect, emptyEdgeSet, (function (acc, edge) {
          var edge$1 = maybeApplyToGraph((function (prim, prim$1, prim$2, prim$3) {
                  prim.connect(prim$1, prim$2, prim$3);
                  
                }), edge, graph);
          if (edge$1 !== undefined) {
            return Belt_Set.add(acc, edge$1);
          } else {
            return acc;
          }
        }));
  return {
          nodes: graph.nodes,
          edges: graph.edges,
          actuallyConnectedEdges: nowConnected
        };
}

function replaceNode(key, newNode, graph) {
  var match = partitionEdgesWithNode(key, graph.actuallyConnectedEdges);
  disconnectEdges(match[0], graph);
  var newNodes = Belt_MapString.set(graph.nodes, key, newNode);
  return {
          nodes: newNodes,
          edges: graph.edges,
          actuallyConnectedEdges: match[1]
        };
}

exports.EdgeComparator = EdgeComparator;
exports.emptyEdgeSet = emptyEdgeSet;
exports.emptyAudioGraph = emptyAudioGraph;
exports.getNode = getNode;
exports.addNode = addNode;
exports.partitionEdgesWithNode = partitionEdgesWithNode;
exports.removeAllEdgesInvolvingNode = removeAllEdgesInvolvingNode;
exports.removeNode = removeNode;
exports.addEdge = addEdge;
exports.removeEdge = removeEdge;
exports.maybeApplyToGraph = maybeApplyToGraph;
exports.disconnectEdges = disconnectEdges;
exports.updateConnections = updateConnections;
exports.replaceNode = replaceNode;
/* EdgeComparator Not a pure module */
